<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Chapter 1</title>

  </head>
<body>
  <h1>Chapter 1: Values, Types, and Operators</h1>
  <h2>Data, Bits, Values</h2>
    <p>Everything in a computer is data. &quot;Anything that isn't data simply does not exist,&quot; (Haverbeke 11). All data is stored as bits, which are &quot;any kind of two-valued things, usually described as zeros and ones.&quot; However, bits can also be made up of other things: &quot;such as high or low electrical charge, a strong or weak signal, or a shiny or dull spot on the surface of a CD&quot;, (Haverbeke 11).</p>
    <p>Ones and zeros is a fundamental way to model information that happens to be &quot;two-valued&quot; so it's convenient way to describe how info is stored in bits.</p>
    <p>The binary system uses 1's and 0's to model numbers in the following way with two digits...&quot;and the weight of each increases by a factor of 2 from right to left,&quot; (Haverbeke 4).</p>
    <div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="dv">    0</span>   <span class="dv">0</span>   <span class="dv">0</span>   <span class="dv">0</span>   <span class="dv">1</span>   <span class="dv">1</span>   <span class="dv">0</span>   <span class="dv">1</span>
    <span class="dv">128</span> <span class="dv">64</span>  <span class="dv">32</span>  <span class="dv">16</span>  <span class="dv">8</span>   <span class="dv">4</span>   <span class="dv">2</span>   <span class="dv">1</span></code></pre></div>
    <p>Above, we have 1's over the weights of 1, 4, and 8. Added together, these numbers are 13. Thus it's possible to show the number 13 using the two-valued syntax of binary (11 bottom).</p>
  <h2>Values</h2>
    <p>Modern computers have 30 billion bits from which to work with and create data (Haverbeke 14). In order to keep track of so many bits, the Javascript environment enables the programmer to create pieces of information from bits and save them as values. &quot;Each value has a type that determines its role,&quot; (Haverbeke 14). Types of values:</p>
    <p>numbers strings Booleans objects functions undefined values</p>
    <p>In order to create a value, a programmer simply writes the values into the build environment and its there. Interesting to note that values dissipate back into the sea of bits once they are not being used anymore (Haverbeke 14). Thus storage becomes more of a problem when a program uses many bits or values at once.</p>
  <h2>Numbers</h2>
  <!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%"><span style="color: #009999">9</span>
<span style="color: #009999">1</span>
</pre>

    <p>The above program will cause the numbers 9 and -1 to be created in the sea of bits and exist for the duration of the program.</p>
    <p>JS uses a maximum of 64 bits to store a number value. Thus there are theoretically 2^64 (18 quintillion) different numbers that are possible (64 different bits with the possibility of a 0 or a 1 (thus 2 options) at each bit).</p>
    <p>Back in the day, there were only 8 bits or 16 bits, which only provide for 2^8 or 2^16 different numbers. This means large numbers were not possible and programs would &quot;overflow&quot; available amount of bits (Haverbeke 13).</p>
    <p>Numbers with a decimal number require bits to store the location of the decimal point, and negative numbers steal away a bit for the negative sign, so the real amount of numbers is 9 quadrillion.</p>
    <p>Large numbers/small numbers can be created with scientific notation:</p>
    <!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%"><span style="color: #009999">3.22e6</span>;
<span style="color: #aaaaaa; font-style: italic">//3220000</span>
</pre>
    <p>Whole numbers (integers) can be reasoned about with certainty as long as they are smaller than 9 quadrillion. However, floats (numbers with decimal points) are not exact when their value stretches out beyond 64 bits. Still overflow like back in the day, but far less so.</p>
    <!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%">.<span style="color: #009999">35</span> <span style="color: #aaaaaa; font-style: italic">//exact float </span>
<span style="color: #009999">3332222</span>/<span style="color: #009999">133</span>; <span style="color: #aaaaaa; font-style: italic">//25054.300751879699 etc continuing on past 64-bits</span>
</pre>

  <h3>Arithmetic</h3>
    <p>We can reason about numbers by performing arithmetic, using operators that perform certain actions on the numbers that appear beside them.</p>
    <!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%"><span style="color: #009999">3</span> * <span style="color: #009999">4</span> <span style="color: #aaaaaa; font-style: italic">//multiplies 3 and 4 </span>
<span style="color: #009999">3</span> / <span style="color: #009999">6</span> <span style="color: #aaaaaa; font-style: italic">// divides 3 by 6</span>
</pre>

    <p>&quot;Putting an operator between two values will apply it to those values and produce a new value,&quot; (Haverbeke 13).</p>
    <p>This is similar to Abelson et al's description of operators being applied to operands. However, in JS operators are not functions, while operators are considered procedures in Scheme.</p>
    <p>Also, the interpreter follows PEMDAS rules to determine which operation takes precedent for complex operations:</p>
    <!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%"><span style="color: #009999">3</span> * <span style="color: #009999">4</span> - <span style="color: #009999">4</span> <span style="color: #aaaaaa; font-style: italic">// gets resolved to: 12 - 4, which gets resolved to 8</span>
</pre>
    <p>EJS recommends to use () when an issue of precedence might occur.</p>
    <p>A dope operator is modulo, or remainder which looks like <span style="margin: 0; line-height: 125%; font-family: monospace; white-space: pre;">%</span> and works in the following way:</p>
    <!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%">x % y <span style="color: #aaaaaa; font-style: italic">// remainder of x/y </span>
<span style="color: #009999">4</span> / <span style="color: #009999">7</span> <span style="color: #aaaaaa; font-style: italic">// 3</span>
</pre>

    <p>A dope use of modulo is to check if a number is even or odd. Let's just go ahead and skip a few chapters to peep how that would work:</p>
    <!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%"><span style="color: #0000aa">function</span> evenOrOdd(n) {
  <span style="color: #0000aa">if</span> (n % <span style="color: #009999">2</span> === <span style="color: #009999">0</span> &amp;&amp; n % <span style="color: #009999">2</span> === -<span style="color: #009999">0</span>) {
    <span style="color: #0000aa">return</span> <span style="color: #aa5500">&quot;even&quot;</span>;
  }
    <span style="color: #0000aa">return</span>  <span style="color: #aa5500">&quot;odd&quot;</span>;
};
</pre>


    <h3>(Tangent over!) # Special Numbers!</h3>
    <p>The following are of type number but do not act like other numbers in a program.</p>
    <!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%"><span style="color: #0000aa">Infinity</span>
-<span style="color: #0000aa">Infinity</span>
</pre>
    <p>These above aren't empirically useful really and can end up introducing NaN into programs.</p>
    <pre style="margin: 0; line-height: 125%"><span style="color: #0000aa">NaN</span></pre>
    <p>means &quot;not a number&quot;. A program will result in this number upon performing &quot;numeric operations that don't yield a precise, meaningful result&quot; (Haverbeke 14). Some examples of computations that can introduce NaN:</p>
    <!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%"><span style="color: #0000aa">Infinity</span> - <span style="color: #0000aa">Infinity</span>; <span style="color: #aaaaaa; font-style: italic">// NaN</span>
<span style="color: #009999">0</span>/<span style="color: #009999">0</span>; <span style="color: #aaaaaa; font-style: italic">// NaN</span>
</pre>
  <h2>Strings</h2>
  <p>Strings are another primitive or basic data type that are used to represent text (Haverbeke 14). Strings are characters enclosed in quotation marks.</p>
  <!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%"><span style="color: #aa5500">&quot;I&#39;m a string&quot;</span>
<span style="color: #aa5500">&quot;I can have numbers, see: 444&quot;</span>
</pre>

  <p>However, there are certain characters that can only be included in a string using an escape key:<br />
  </p>
  <!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%">console.log(<span style="color: #aa5500">&quot;This will be on one line\nThis will be on another&quot;</span>);
<span style="color: #aaaaaa; font-style: italic">// &quot;This will be on one line&quot;</span>
<span style="color: #aaaaaa; font-style: italic">// &quot;This will be on another&quot; </span>
<span style="color: #0000aa">var</span> quote = <span style="color: #aa5500">&#39;He said\&quot;hello\&quot;&#39;</span>;
console.log(quote);
<span style="color: #aaaaaa; font-style: italic">// &#39;He said &quot;hello&quot;&#39;</span>
</pre>
  <p>A backslash can be introduced into a string by placing two escape keys next to each other. The result of this will be a single backslash remaining in the string.</p>
  <!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%">console.log(<span style="color: #aa5500">&quot;Yo\\Check it\\Sick rhymes\\Every second&quot;</span>);
<span style="color: #aaaaaa; font-style: italic">// &quot;Yo\Check it\Sick rhymes\Every second&quot;</span>
</pre>
  <p>There is an operator used on strings, called the concatination operator. This operator brings together different strings as a single string:</p>
  <!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%"><span style="color: #aa5500">&quot;Oh &quot;</span> + <span style="color: #aa5500">&quot;hello &quot;</span> + <span style="color: #aa5500">&quot;there&quot;</span>
<span style="color: #aaaaaa; font-style: italic">// &quot;Oh hello there&quot;;</span>
</pre>
  <h3>Urinary Operators</h3>
  <p>So far we've seen symbolic operators: +, , /, %. However there are also operators that are words.</p>
  <p>typeof gives the stringified name of the value immediately to its right:</p>
  <!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%"><span style="color: #0000aa">typeof</span> <span style="color: #aa5500">&quot;cat&quot;</span>;
<span style="color: #aaaaaa; font-style: italic">// string</span>
<span style="color: #0000aa">typeof</span> <span style="color: #009999">6</span>;
<span style="color: #aaaaaa; font-style: italic">// number</span>
</pre>
  <p>Note that the program isn't visible to the human eye. We can make it visible by passing our expressions above to the console.log function which makes the data passed to it visible in the console.<!-- HTML generated using hilite.me --><!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%">console.log(<span style="color: #0000aa">typeof</span> <span style="color: #009999">7</span>);
<span style="color: #aaaaaa; font-style: italic">// &quot;number&quot;</span>
</pre>
<p><span style = "font-family: monospace; white-space: pre; color: #0000aa;">typeof</span> is an example of a urinary operator because it does work on one value, namely the value to it's right.</p>
  <p>the <!-- HTML generated using hilite.me --><span style="margin: 0; line-height: 125%">-</span> can also act as an urinary operator when it changes a number's sign from negative to positive or vice versa. (Haverbeke 16).</p>
  <!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%">(- (<span style="color: #009999">8</span> - <span style="color: #009999">4</span>));
<span style="color: #aaaaaa; font-style: italic">//-4</span>
</pre>
  <h2>Boolean Values</h2>
  <p>Booleans are another primitive data type that &quot;distinguish between two possibilities like 'yes' and 'no' and 'on' and 'off' (Haverbeke 16).&quot;</p>
  <p>Boolean values can be created by simply writing their names as happens with the other types we've seen:</p>
  <!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%"><span style="color: #0000aa">true</span>
<span style="color: #0000aa">false</span>
</pre>
  <p>Some other ways we can produce Booleans (that also happen to include binary operators!)</p>
  <h3>Comparisons</h3>
  <p>Greater than &gt; and less than &lt; are available for us to use in the Javascript language. when comparing numbers, these operators can result in a Boolean (Haverbeke 16):</p>
  <!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%"><span style="color: #009999">6 </span>&lt;<span style="color: #009999"> 6</span>;
<span style="color: #aaaaaa; font-style: italic">// false</span>
<span style="color: #009999">4</span> === <span style="color: #009999">4</span>;
<span style="color: #aaaaaa; font-style: italic">// true</span>
</pre>
  <p>These operators can also be applied to strings to produce Boolean values. Strings are assigned a value according to the Unicode standard, which is a numbered system for characters that includes much of the characters found throughout the world - most spoken languages and ancient alphabets as well (Haverbeke 16). some rough rules about letter values in Javascript (Haverbeke 16):</p>
  <ul>
  <li><p>value increases as alphabet continues</p></li>
  <li><p>uppercase letters are less than lowercase letters (this is because the capitalized roman alphabet appears before the lowercase roman alphabet in the Unicode standard)</p></li>
  </ul>
  <!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%"><span style="color: #aa5500">&quot;Apple&quot;</span> &gt; <span style="color: #aa5500">&quot;Bapple&quot;</span>
<span style="color: #aaaaaa; font-style: italic">//false</span>
</pre>
  <p>Other operators:</p>
  <p>greater than or equal to <!-- HTML generated using hilite.me --><span style="margin: 0; line-height: 125%; font-family: monospace; white-space: pre;">>=</span>, less than or equal to <span style="margin: 0; line-height: 125%; font-family: monospace; white-space: pre;">>=</span>, equal to <span style="margin: 0; line-height: 125%; font-family: monospace; white-space: pre;">===</span>, and not equal to <span style="margin: 0; line-height: 125%; font-family: monospace; white-space: pre;">!=</span> all perform the operations that you probably assume they do, with some quirks</p>
  <!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%"><span style="color: #aa5500">&quot;cat&quot;</span> != <span style="color: #aa5500">&quot;dog&quot;</span>;
<span style="color: #aaaaaa; font-style: italic">//true</span></pre>
  <p>Note: I know Haverbeke uses <span style="margin: 0; line-height: 125%; font-family: monospace; white-space: pre;"> ==</span> instead of  <span style="margin: 0; line-height: 125%; font-family: monospace; white-space: pre;">===</span> for equal to but for all intents and purposes  <span style="margin: 0; line-height: 125%; font-family: monospace; white-space: pre;">===</span> is better than  <span style="margin: 0; line-height: 125%; font-family: monospace; white-space: pre;">==</span>. Trust me.</p>
  <p>Only 1 value not equal to itself!!!! (17)</p>
  <!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%"><span style="color: #0000aa">NaN</span> === <span style="color: #0000aa">NaN</span>;
<span style="color: #aaaaaa; font-style: italic">//false</span>
</pre>
  <p>Good ass summary of why this is: &quot;<span style = "font-family: monospace; white-space: pre; color: #0000aa;">NaN</span> is supposed to denote the result of a nonsensical computation, and as such, it isn't equal to the result of any other nonsensical computations&quot; (17).</p>
  <h3>Logical Operators</h3>
  <p>Logical operators are used to compare boolean values to each other!</p>
  <p><!-- HTML generated using hilite.me --><span style="margin: 0; line-height: 125%;font-family: monospace; white-space: pre;">&&</span> AKA 'and' is true if the value on the left and right side of the operator are both true (17). The expression will return the value on the left if that value carries a false Boolean value. If the value on the left is true The expression will return the value on the right if the value on the right is true or false.</p>
  <!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%"><span style="color: #0000aa">null</span> &amp;&amp; <span style="color: #0000aa">true</span>;
<span style="color: #aaaaaa; font-style: italic">//null (also entire expression is false)</span>
<span style="color: #aa5500">&quot;dog&quot;</span> &amp;&amp; <span style="color: #009999">0</span>;
<span style="color: #aaaaaa; font-style: italic">// 0 (also entrie expression is false)</span>
<span style="color: #aa5500">&quot;dog&quot;</span> &amp;&amp; <span style="color: #aa5500">&quot;cat&quot;</span>;
<span style="color: #aaaaaa; font-style: italic">// &quot;cat&quot; (also entire expression is true)</span>
</pre>

  <p><span style="margin: 0; line-height: 125%;font-family: monospace; white-space: pre;">||</span> AKA or is true when either the value to the left or right carries the Boolean value of true. The interpreter searches for true and once it finds it, it's done! Like the english equivalent of &quot; either or&quot;. The interpreter starts with the value on the left side of the || and if that value is true than the expression is true and it returns that value. If the value on the left side of the || is false ,than the expression will return the value on the right. In this case the value on the right carries a true value than the entire expression i true, otherwise the entire expression is false.</p>
  <!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%"><span style="color: #0000aa">null</span> &amp;&amp; <span style="color: #0000aa">true</span>;
<span style="color: #aaaaaa; font-style: italic">// null (also entire expression is false)</span>
<span style="color: #aa5500">&quot;dog&quot;</span> &amp;&amp; <span style="color: #009999">0</span>;
<span style="color: #aaaaaa; font-style: italic">// 0 (also entrie expression is false)</span>
<span style="color: #aa5500">&quot;dog&quot;</span> &amp;&amp; <span style="color: #aa5500">&quot;cat&quot;</span>;
<span style="color: #aaaaaa; font-style: italic">// &quot;cat&quot; (also entire expression is true)</span>
</pre>
  <p><span style="margin: 0; line-height: 125%;font-family: monospace; white-space: pre;">!</span> AKA not changes the Boolean value of the value to it's right (note this is a urinary operator)</p>
  <!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%">!<span style="color: #0000aa">false</span>;
<span style="color: #aaaaaa; font-style: italic">// true</span>
!<span style="color: #009999">7</span>
<span style="color: #aaaaaa; font-style: italic">//false</span>
</pre>

  <h3>Chaining comparison and logical operators</h3>
  <p>Though I'm a proponent of using parenthesis to clarify precedence, the JS rules have been set up so that <span style="margin: 0; line-height: 125%;font-family: monospace; white-space: pre;">||</span> has lowest precedence, than <span style="margin: 0; line-height: 125%;font-family: monospace; white-space: pre;">&amp;&amp;</span> than comparison operators, than PEMDAs. Thus the math reasoning will be completed before comparisons, than the Booleans that result form the comparisons will finally be evaluated as part of the logical operators. (17).</p>
  <!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%"><span style="color: #009999">1</span> + <span style="color: #009999">1</span> == <span style="color: #009999">2</span> &amp;&amp; <span style="color: #009999">10</span> * <span style="color: #009999">10</span> &gt; <span style="color: #009999">50</span>;
<span style="color: #009999">2</span> == <span style="color: #009999">2</span> &amp;&amp; <span style="color: #009999">100</span> &gt; <span style="color: #009999">50</span>;
<span style="color: #0000aa">true</span> &amp;&amp; <span style="color: #0000aa">true</span>;
<span style="color: #aaaaaa; font-style: italic">// true</span>
</pre>
  <p>When the first value is true the operator returns the second value and when the first value is false the operator returns the third value. It's like the first Boolean chooses if the second or third value will be returned.</p>
  <h2>Undefined Values</h2>
  <!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%"><span style="color: #0000aa">null</span>
<span style="color: #0000aa">undefined</span>
</pre>
  <p>Both of the values above &quot;denote the absence of a meaningful value&quot; (Haverbeke 18). Undefined is many times provided asa default value because an operation has to supply some value. Haverbeke suggests thinking of these values as interchangable.</p>
  <p>I would humbly add the small distinction that undefined is a type upon itself, while null is type object.</p>
  <!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%"><span style="color: #0000aa">typeof</span>(<span style="color: #0000aa">null</span>);
<span style="color: #aaaaaa; font-style: italic">// object</span>
<span style="color: #0000aa">typeof</span>(<span style="color: #0000aa">undefined</span>);
<span style="color: #aaaaaa; font-style: italic">// undefined</span>
</pre>
  <h3>Automatic Type Conversion</h3>
  <p>Javascript's reputation as a liberal language that accepts many operations even if they can lead to unexpected results is evidenced in the following operations:</p>
  <!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%"><span style="color: #009999">8</span> * <span style="color: #0000aa">null</span>;
<span style="color: #aaaaaa; font-style: italic">// 0</span>
<span style="color: #aa5500">&quot;5&quot;</span> - <span style="color: #009999">1</span>;
<span style="color: #aaaaaa; font-style: italic">//4</span>
<span style="color: #aa5500">&quot;5&quot;</span> + <span style="color: #009999">1</span>;
<span style="color: #aaaaaa; font-style: italic">// 51</span>
<span style="color: #aa5500">&quot;five&quot;</span> * <span style="color: #009999">2</span>;
<span style="color: #aaaaaa; font-style: italic">// NaN</span>
<span style="color: #0000aa">false</span> == <span style="color: #009999">0</span>;
<span style="color: #aaaaaa; font-style: italic">// true</span>
</pre>
  <p>Above is an example of type coercion. When we have an operator working on an unexpected value, &quot;Javascript will quickly convert that value to the type it wants, using a set of rules that often aren't what you expect,&quot; (Haverbeke 18).</p>
  <p>What's going on here?</p>
  <!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%"><span style="color: #009999">8</span> * <span style="color: #0000aa">null</span>;
<span style="color: #aaaaaa; font-style: italic">// 0</span>
</pre>
  <p>Js interprets a number in 8, so it converts null to it's numerical equivalent of 0 and applies the operator to 0.</p>
  <!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%"><span style="color: #aa5500">&quot;5&quot;</span> - <span style="color: #009999">1</span>;
<span style="color: #aaaaaa; font-style: italic">// 4</span>
</pre>

  <p>&quot;5&quot; gets changed from a string to a number, so the subtraction operator can reason about two number types.</p><!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%"><span style="color: #aa5500">&quot;5&quot;</span> + <span style="color: #009999">1</span>;
<span style="color: #aaaaaa; font-style: italic">// &quot;51&quot;</span>
</pre>
  <p>Here, the interpreter starts a string concatination so the 1 gets changed from a type number to a type string.</p>
  <p>Instead of listing an (impossible) exhaustive list of all possibilities of type coercion, I think it's just important to understand that if a program is returning string results, type coercion could be one of the issues.</p>
  <h3>How <span style="font-family: monospace; white-space: pre; color: #0000aa;">NaN</span> can get all up in a program.</h3>
  <p>We've seen that <span style="font-family: monospace; white-space: pre; color: #0000aa;">NaN</span> is the result of a nonsensical operation. Type conversion can happen when certain values that are &quot;close enough&quot; to the values Javascript is looking for. However once operations start involving values that are further away from the values JS desires, a &quot;nonsensical operation&quot; is most likely coming, which will result in <span style="font-family: monospace; white-space: pre; color: #0000aa;">NaN</span>.</p>
  <!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%">(<span style="color: #aa5500">&quot;seven&quot;</span> * <span style="color: #009999">8</span>);
<span style="color: #aaaaaa; font-style: italic">// NaN</span>
</pre>
  <p>Here there is no * that reasons about strings, so this becomes a nonsensical operation. Haverbeke suggests that &quot;Further arithmetic operations on <span style="font-family: monospace; white-space: pre; color: #0000aa;">NaN</span> keep producing <span style="font-family: monospace; white-space: pre; color: #0000aa;">NaN</span>, so if you find yourself getting one of those in an unexpected place, look for accidental type conversion&quot;</p>
  <h3>Weird stuff with <span style="margin: 0; line-height: 125%; font-family: monospace; white-space: pre;">==</span> and <span style="margin: 0; line-height: 125%; font-family: monospace; white-space: pre;">===</span></h3>
  <p>When we use <span style="margin: 0; line-height: 125%; font-family: monospace; white-space: pre;">==</span> to compare values that could be converted to another type, weird stuff can happen:</p>
  <!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%"><span style="color: #009999">"15"</span> == <span style="color: #009999">15</span>;
<span style="color: #aaaaaa; font-style: italic">// true</span>
</pre>
  <p>Again, the number type has been converted to a string. However, when we use undefined or null with <span style="margin: 0; line-height: 125%; font-family: monospace; white-space: pre;">==</span>, this will only result in true when undefined or null is on either side of <span style="margin: 0; line-height: 125%; font-family: monospace; white-space: pre;">==</span>. (Haverbeke 19). Even if you compare a value with boolean type false to undefined or null, no type conversion happens:</p>
  <!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%"><span style="color: #aa5500">&quot;&quot;</span> == <span style="color: #0000aa">null</span>;
<span style="color: #aaaaaa; font-style: italic">// false</span>
<span style="color: #009999">0</span> == <span style="color: #0000aa">undefined</span>;
<span style="color: #aaaaaa; font-style: italic">// false</span>
</pre>
<p> However:</p>
<!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%"><span style="color: #0000aa">null</span> == <span style="color: #0000aa">undefined</span>;
<span style="color: #aaaaaa; font-style: italic">// true</span>
<span style="color: #0000aa">undefined</span> == <span style="color: #0000aa">true</span>;
<span style="color: #aaaaaa; font-style: italic">// true </span>
</pre>

  <p>Haverbeke brings up a good point that if we want to test weather a value has a real value instead of undefined or null, that value can be compared to null with the <span style="margin: 0; line-height: 125%; font-family: monospace; white-space: pre;">==</span> operator.</p>
  <p>When we use <span style="margin: 0; line-height: 125%; font-family: monospace; white-space: pre;">==</span> weird stuff happens: &quot;But when the types differ (when using <span style="margin: 0; line-height: 125%; font-family: monospace; white-space: pre;">==</span>), Javascript uses a complicated and confusing set of rules to determine what to do. In most cases, it just tries to convert one of the values to the other value's type,&quot; (Haverbeke 19).</p>
  <p>Because <span style="margin: 0; line-height: 125%; font-family: monospace; white-space: pre;">==</span> invloves converting types in order to produce a value, we can use <span style="margin: 0; line-height: 125%; font-family: monospace; white-space: pre;">===</span> to perform a &quot;deep comparison&quot; between values. <span style="margin: 0; line-height: 125%; font-family: monospace; white-space: pre;">===</span> &quot;Tests whether a value is precisely equal to the other, and <span style="margin: 0; line-height: 125%; font-family: monospace; white-space: pre;">!==</span> tests whether it is not precisely equal,&quot; (Haverbeke 14).</p>
  <!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%"><span style="color: #009999">0</span> == <span style="color: #aa5500">&quot;&quot;</span>;
<span style="color: #aaaaaa; font-style: italic">// true. </span>
<span style="color: #009999">0</span> === <span style="color: #aa5500">&quot;&quot;</span>;
<span style="color: #aaaaaa; font-style: italic">// false. </span>
</pre>

  <p>Pretty much just always use <span style="margin: 0; line-height: 125%; font-family: monospace; white-space: pre;">===</span> and <span style="margin: 0; line-height: 125%; font-family: monospace; white-space: pre;">!==</span>. If we want to see if a value has a real value we can compare it to <span style="margin: 0; line-height: 125%; font-family: monospace; white-space: pre;">==</span>.</p>
  <h3>Short-Circiuting of Logcal Operators</h3>
  <p><span style="margin: 0; line-height: 125%; font-family: monospace; white-space: pre;">&amp;&amp;</span> and <span style="margin: 0; line-height: 125%; font-family: monospace; white-space: pre;">||</span> convert the values they operate on starting from left to right and will perform differently based on the Boolean value of the left-hand operand.</p>
  <p>Because <span style="margin: 0; line-height: 125%; font-family: monospace; white-space: pre;">&amp;&amp;</span> needs both values it operates on to be true, if the left-hand value is false, than the interpreter will ignore the value to the right, return the left-hand value, and the entire expression will be false.</p>
  <!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%">(<span style="color: #0000aa">null</span> &amp;&amp; <span style="color: #009999">100</span>);
<span style="color: #aaaaaa; font-style: italic">// false (and entire expression is false)</span>
</pre>

  <p>Because <span style="margin: 0; line-height: 125%; font-family: monospace; white-space: pre;">||</span> only needs 1 value to be true, if the left-hand value carries true, than the interpreter will not look at the value to the right, return the value on the left, and the entire expression will be false.</p>
  <!-- HTML generated using hilite.me --><pre style="margin: 0; line-height: 125%"><span style="color: #009999">1</span> || undeclaredvariable;
<span style="color: #aaaaaa; font-style: italic">// 1 (and entire expression is true)</span>
</pre>
  <h2>Summary!</h2>

  <p>We have looked at four primitive data types: strings, numbers, Booleans, and undefined values. We also thought how we reason about these values. We can use math operators to perform arithemtic, we can use string concatination to join parts of text together, Booleans enable use to make programmtic decisions based on a two-valued type, and we have scratched the surface of how nothingness is modeled with undefined values.</p>
  <p>We create <span style = "color: #0000aa; line-height: 125%; font-family: monospace; white-space: pre;">null undefined true</span> and <span style = "color: #0000aa; line-height: 125%; font-family: monospace; white-space: pre;">false</span> by typing their name.</p>

  <p>We create string and numbers by typing their value: <span style = "color: #009999;line-height: 125%; font-family: monospace; white-space: pre; ">3</span>, &quot;cat&quot;
  These values can be combined/reasoned about by using operators <span style="margin: 0; line-height: 125%; font-family: monospace; white-space: pre;">+ * /</span> etc.
  Operators can be</p>
  <p>urinary (operate on one value): <span style = "color: #0000aa; line-height: 125%; font-family: monospace; white-space: pre;">typeof</span>, <span style="margin: 0; line-height: 125%; font-family: monospace; white-space: pre;">-</span> </p>
  <p>binary (operate on two values): <span style="margin: 0; line-height: 125%; font-family: monospace; white-space: pre;">&gt; &lt; === !== &gt;= * - + || &amp;&amp; !</span></p>
  ternary (operates on three values)<span style="margin: 0; line-height: 125%; font-family: monospace; white-space: pre;"> ? :</span>
  <p>Based on what we've learned so far we can do &quot;pocket calculator&quot; type calcuations but not much more. </p>



</body>
</html>
