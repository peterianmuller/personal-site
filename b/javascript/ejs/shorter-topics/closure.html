<p>&quot;(B)eing able to reference a specific instance of local variables in an enclosing function-is called closure. A function that &quot;closes over&quot; some local variables is called a closure,&quot; (49).</p>
<p>We have <a href="scopes.html">seen</a> that functions have the ability to create local variables that only exist in their scopes. Haverbeke describes how a closure can provide a way for a program to access local variables from a wider scope.</p>
<p>A simple example of this:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">
<span class="kw">var</span> returnLocalVariable <span class="op">=</span> <span class="kw">function</span>(n)<span class="op">{</span>
    <span class="kw">var</span> localVariable <span class="op">=</span> n<span class="op">;</span>
    <span class="cf">return</span> <span class="kw">function</span>()<span class="op">{</span>
      <span class="cf">return</span> localVariable<span class="op">;</span>
    <span class="op">}</span>
<span class="op">}</span>

<span class="kw">var</span> save1 <span class="op">=</span> <span class="at">returnLocalVariable</span>(<span class="dv">1</span>)<span class="op">;</span>
<span class="va">console</span>.<span class="at">log</span>(save1)<span class="op">;</span> <span class="co">// [Function] </span>
<span class="va">console</span>.<span class="at">log</span>(<span class="at">save1</span>())<span class="op">;</span> <span class="co">//1</span>

<span class="kw">var</span> saveHello <span class="op">=</span> <span class="at">returnLocalVariable</span>(<span class="st">&#39;Hello&#39;</span>)<span class="op">;</span>
<span class="va">console</span>.<span class="at">log</span>(saveHello)<span class="op">;</span> <span class="co">//[Function]</span>
<span class="va">console</span>.<span class="at">log</span>(<span class="at">saveHello</span>())<span class="op">;</span> <span class="co">// &#39;Hello&#39;</span></code></pre></div>
<p>So here <code>returnLocalVariable</code> creates a local variable <code>localVariable</code> and has it point to the argument passed to <code>returnLocalVariable</code>. The function then returns another function that takes no arguments and returns <code>localVariable</code>.</p>
<p>Based on the hierarchy of scopes, we should not be able to return <code>localVariable</code> because it's not returned in the scope of <code>returnLocalVariable</code>, but instead returned in the function that <code>returnLocalVariable</code> returns.</p>
<p>However, clearly based on the examples in the code above we are able to access the value 1 in <code>save1</code> and <code>Hello</code> in <code>saveHello</code>.</p>
<p>This is possible because <code>save1</code> and <code>saveHello</code> both point to functions - after all the original function <code>returnLocalVariable</code> returns a function. We can see this when we log <code>save1</code> and <code>saveHello</code> to the console and see a function object on our screen. However, we can return <code>localVariable</code> by invoking <code>save1</code> and <code>saveHello</code>. This means we are getting into the nested function's scope, and successfully returning <code>localVariable</code>, a value that was declared when we first defined <code>save1</code> and <code>saveHello</code>.</p>
<p>Also, importantly, each invocation of <code>returnLocalVariable</code> doesn't interfere with the other. &quot;In fact, multiple instances of the variable can be alive at the same time, which is another good illustration of the concept that local variables really are re-created for every call-different calls can't trample on one another's local variables&quot;(49).</p>
<p>Let's check out another example of a closure that does some work outside of simpyl returning a local variable of a nested scope. Haverbeke uses a multiple example, but just to try and differentiate, I'll use a divide function.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">
<span class="kw">var</span> divideBy <span class="op">=</span> <span class="kw">function</span>(divisor) <span class="op">{</span>
    <span class="cf">return</span> <span class="kw">function</span>(numerator) <span class="op">{</span>
        <span class="cf">return</span> numerator/divisor<span class="op">;</span>
    <span class="op">}</span>
<span class="op">};</span>

<span class="kw">var</span> divideByThree <span class="op">=</span> <span class="at">divideBy</span>(<span class="dv">3</span>)<span class="op">;</span>
<span class="va">console</span>.<span class="at">log</span>(<span class="at">divideByThree</span>(<span class="dv">3</span>))<span class="op">;</span> <span class="co">//1</span>
<span class="va">console</span>.<span class="at">log</span>(<span class="at">divideByThree</span>(<span class="dv">6</span>))<span class="op">;</span> <span class="co">//2</span>


<span class="kw">var</span> divideBySix <span class="op">=</span> <span class="at">divideBy</span>(<span class="dv">6</span>)<span class="op">;</span>
<span class="va">console</span>.<span class="at">log</span>(<span class="at">divideBySix</span>(<span class="dv">4</span>))<span class="op">;</span> <span class="co">// 0.67</span>
<span class="va">console</span>.<span class="at">log</span>(<span class="at">divideBySix</span>(<span class="dv">12</span>))<span class="op">;</span> <span class="co">// 2</span></code></pre></div>
<p><code>divideBy</code> provides takes in one parameter that will serve as the divisor and then returns a function whose paramter will be a numerator. The nested function then returns the division of the numerator by the divisor. What's dope here is that we can declare a function that will have a divisor, and then invoke that function with arbitrary numerators.</p>
<p>This means we can have a helper function that is more specific than the <code>/</code> operator - a function with a dedicated divisor that we can recycle without having to declare a divisor each time we use the function.</p>
