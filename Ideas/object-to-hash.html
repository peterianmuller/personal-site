<p>Okok! Today's codewars challange involves converting an obect to a 'hash', which seems to be a string that lists out the key-value pairs of the input argument. Shouts to the creator of the challange jhoffner.</p>
<p>The test:</p>
<p><code>//solution({a: 1, b: '2'}) // should return &quot;a = 1,b = 2&quot;</code></p>
<p>My soultion:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">solution</span>(pairs)<span class="op">{</span>
 <span class="kw">var</span> string <span class="op">=</span> <span class="va">Object</span>.<span class="at">keys</span>(pairs).<span class="at">reduce</span>(<span class="kw">function</span>(acc<span class="op">,</span> curr)<span class="op">{</span>
   <span class="cf">return</span>  acc <span class="op">+</span> curr <span class="op">+</span> <span class="st">&quot; = &quot;</span> <span class="op">+</span> pairs[curr] <span class="op">+</span> <span class="st">&quot;,&quot;</span><span class="op">;</span>    
 <span class="op">},</span> <span class="st">&quot;&quot;</span>).<span class="at">split</span>(<span class="st">&#39;&#39;</span>)<span class="op">;</span>
 <span class="va">string</span>.<span class="at">pop</span>()<span class="op">;</span>
 <span class="cf">return</span> <span class="va">string</span>.<span class="at">join</span>(<span class="st">&#39;&#39;</span>)<span class="op">;</span> 
<span class="op">};</span></code></pre></div>
<p>What I like about this challange is that I tried out using <code>.reduce()</code> to build up a result value that grows as the accumulator. The first uses of <code>.reduce()</code> that I got used to would build up a single value, such as a sum:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">
<span class="kw">var</span> numsToSum <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span>]<span class="op">;</span>
<span class="kw">var</span> total <span class="op">=</span> <span class="va">numsToSum</span>.<span class="at">reduce</span>(<span class="kw">function</span>(acc<span class="op">,</span> current)<span class="op">{</span>
    <span class="cf">return</span> acc <span class="op">+</span> current<span class="op">;</span>
<span class="op">}</span>)<span class="op">;</span>

total<span class="op">;</span> <span class="co">// 10</span></code></pre></div>
<p>However, there's no reason why we can't build up a length-based value as the accumulator, such as a string or collections like arrays or objects.</p>
<p>This problem provides an opportunity to expand a reuslt string as the accumulator.</p>
<p>```javascript function solution(pairs){</p>
<p>var string = Object.keys(pairs).reduce(function(acc, curr){ return acc + curr + &quot; = &quot; + pairs[curr] + &quot;,&quot;;</p>
<p>//acc is set to an empty string that will house the hash as it grows<br />
}, &quot;&quot;).split(''); string.pop();</p>
<p>return string.join(''); };</p>
<p>Note also the use of <code>Object.keys(pairs)</code> which is a dope <code>object</code> method that returns an array of the keys in <code>pairs</code>. We can acces the values that these keys point to by referencing the pairs object in the callback to reduce: <code>pairs[curr]</code>.</p>
